#本示例说明Localoutlierfactor类的原理,具体类代码见sklearn中_lof.py
#增加一点

import numpy as np
from sklearn.neighbors import LocalOutlierFactor
from sklearn.neighbors import NearestNeighbors

X =np.array( [[10],[20],[30],[40],[50],[50.01],[50.02],[50.03],[60],[70],[80],[90]])
n_neighbors_ = max(1, min(3, X.shape[0] - 1))
#定义数组X及近邻数
distances_fit_X, neighbors_indices_fit_X = NearestNeighbors(n_neighbors=n_neighbors_).fit(X).kneighbors(X)
#NearestNeighbors(n_neighbors=n_neighbors_).fit(X).kneighbors(X)
#用最近邻方法计算X中每行向量的k个近邻及距离

print(distances_fit_X)
#每行分别表示X中该行向量离k个近邻的距离，首列为自己，距离为0
[[0.00e+00 1.00e+01 2.00e+01]
 [0.00e+00 1.00e+01 1.00e+01]
 [0.00e+00 1.00e+01 1.00e+01]
 [0.00e+00 1.00e+01 1.00e+01]
 [0.00e+00 1.00e-02 2.00e-02]
 [0.00e+00 1.00e-02 1.00e-02]
 [0.00e+00 1.00e-02 1.00e-02]
 [0.00e+00 1.00e-02 2.00e-02]
 [0.00e+00 9.97e+00 9.98e+00]
 [0.00e+00 1.00e+01 1.00e+01]
 [0.00e+00 1.00e+01 1.00e+01]
 [0.00e+00 1.00e+01 2.00e+01]]

print(neighbors_indices_fit_X)
#每行表示X中该行向量离k个近邻的编号，即行号
[[ 0  1  2]
 [ 1  2  0]
 [ 2  3  1]
 [ 3  4  2]
 [ 4  5  6]
 [ 5  4  6]
 [ 6  7  5]
 [ 7  6  5]
 [ 8  7  6]
 [ 9 10  8]
 [10 11  9]
 [11 10  9]]
元素
dist_k = distances_fit_X[neighbors_indices_fit_X,n_neighbors_ - 1]
print(dist_k)
#dist_k记录每个行向量的k个近邻元素各自的最大近邻距离，形成该行向量所在邻域元素的最大距离矩阵
#举例看看
#a = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])
#b= np.array([[0, 5], [1, 4], [2, 3], [3, 2], [4, 1], [5, 0]])
#打印a[b]和a[b,1]看看
[[2.00e+01 1.00e+01 1.00e+01]
 [1.00e+01 1.00e+01 2.00e+01]
 [1.00e+01 1.00e+01 1.00e+01]
 [1.00e+01 2.00e-02 1.00e+01]
 [2.00e-02 1.00e-02 1.00e-02]
 [1.00e-02 2.00e-02 1.00e-02]
 [1.00e-02 2.00e-02 1.00e-02]
 [2.00e-02 1.00e-02 1.00e-02]
 [9.98e+00 2.00e-02 1.00e-02]
 [1.00e+01 1.00e+01 9.98e+00]
 [1.00e+01 2.00e+01 1.00e+01]
 [2.00e+01 1.00e+01 1.00e+01]]

reach_dist_array = np.maximum(distances_fit_X, dist_k)
print(reach_dist_array)
#将每行向量邻域元素的最大距离矩阵与该行向量的距离比较，取最大值更新该行向量的领域最大距离矩阵
[[2.00e+01 1.00e+01 2.00e+01]
 [1.00e+01 1.00e+01 2.00e+01]
 [1.00e+01 1.00e+01 1.00e+01]
 [1.00e+01 1.00e+01 1.00e+01]
 [2.00e-02 1.00e-02 2.00e-02]
 [1.00e-02 2.00e-02 1.00e-02]
 [1.00e-02 2.00e-02 1.00e-02]
 [2.00e-02 1.00e-02 2.00e-02]
 [9.98e+00 9.97e+00 9.98e+00]
 [1.00e+01 1.00e+01 1.00e+01]
 [1.00e+01 2.00e+01 1.00e+01]
 [2.00e+01 1.00e+01 2.00e+01]]

lrd= 1. / (np.mean(reach_dist_array, axis=1) + 1e-10)
print(lrd)
#取最大距离矩阵每行平均值，取倒数，形成每行向量的lrd向量
[6.00000000e-02 7.50000000e-02 1.00000000e-01 1.00000000e-01
 5.99999996e+01 7.49999994e+01 7.49999994e+01 5.99999996e+01
 1.00233879e-01 1.00000000e-01 7.50000000e-02 6.00000000e-02]
lrd_ratios_array = (lrd[neighbors_indices_fit_X] /lrd[:, np.newaxis])
print(lrd_ratios_array)
#将每行向量的k近玲lrd除以该行向量的lrd，形成每行的邻域距离比值矩阵
#首列为自己，因此是1，其他列表示该行与近邻距离的比值，大于1说明该行距离相对远
[[  1.           1.25         1.66666667]
 [  1.           1.33333333   0.8       ]
 [  1.           1.           0.75      ]
 [  1.         599.99999641   1.        ]
 [  1.           1.25         1.25      ]
 [  1.           0.8          1.        ]
 [  1.           0.8          1.        ]
 [  1.           1.25         1.25      ]
 [  1.         598.59999641 748.2499944 ]
 [  1.           0.75         1.00233879]
 [  1.           0.8          1.33333333]
 [  1.           1.25         1.66666667]]
negative_outlier_factor_ = -np.mean(lrd_ratios_array, axis=1)
print(negative_outlier_factor_)
#取领域比值矩阵每行的均值负数，接近-1表示处于密集区，远离-1表示处于稀疏区
[  -1.30555556   -1.04444444   -0.91666667 -200.66666547   -1.16666667
   -0.93333333   -0.93333333   -1.16666667 -449.28333027   -0.91744626
   -1.04444444   -1.30555556]

